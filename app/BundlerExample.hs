{-# LANGUAGE BangPatterns, RecordWildCards #-}
import Control.Monad
import System.Environment
import System.FilePath
import System.Directory
import Data.List
import qualified Data.Set as S
import System.IO

libRoot :: FilePath
libRoot = "ライブラリのroot Path"

myModules :: S.Set String
myModules = S.fromList
  [
      "Algorithm.BinSearch"
    , "Algorithm.Compression"
    , "Algorithm.Sort"
    , "Algorithm.TwoSAT"
    , "Algorithm.Mo"

    , "Common.Debug"
    , "Common.IxVector"
    , "Common.IO"
    , "Common.Template"

    , "Data.BIT"
    , "Data.BitSet"
    , "Data.MutableDeque"
    , "Data.MutableHeap"
    , "Data.MutableStack"
    , "Data.MutableQueue"
    , "Data.SegTree.SegTree"
    , "Data.SegTree.Beats"
    , "Data.SegTree.Dynamic"
    , "Data.SegTree.Lazy"
    , "Data.SegTree.Persistent"
    , "Data.SparseTable"
    , "Data.UF"
    , "Data.UFP"
    , "Data.WaveletMatrix"

    , "Graph.BipartiteMatching"
    , "Graph.BellmanFord"
    , "Graph.BFS"
    , "Graph.CSR"
    , "Graph.Dijkstra"
    , "Graph.SCC"
    , "Graph.TopSort"
    , "Graph.MaxFlow"
    , "Graph.MinCostFlow"
    , "Graph.WarshallFloyd"

    , "Math.Convolution.NTT"
    , "Math.FPS"
    , "Math.FPS.Extra"
    , "Math.FPS.Poly"
    , "Math.FPS.Extra"
    , "Math.FPS.Sparse"
    , "Math.FPS.Sparse.Extra"
    , "Math.IntMod"
    , "Math.IntMod.Combinatorics"
    , "Math.Matrix"
    , "Math.SemiRing"
    , "Math.SemiRing.Affine"
    , "Math.SemiRing.AndOr"
    , "Math.SemiRing.MaxMin"
    , "Math.SemiRing.MaxPlus"
    , "Math.SemiRing.MinMax"
    , "Math.SemiRing.MinPlus"
    , "Math.SemiRing.OrAnd"
    , "Math.SemiRing.XorAnd"
  ]

data BundleState = BundleState
  { seenModules :: !(S.Set String)
  , pragmas :: !(S.Set String)
  , imports :: !(S.Set String)
  , contents :: ![String]
  }

initialState :: BundleState
initialState = BundleState S.empty S.empty S.empty []

main :: IO ()
main = do
  !args <- getArgs
  case args of
    [target, output] -> do
      finalState <- collect initialState target
      withFile output WriteMode $ \hOut -> do
        hPutStrLn hOut "-- Generated by cjp-bundle (Reconstructed Style)"
        forM_ (S.toList $ pragmas finalState) (hPutStrLn hOut)
        hPutStrLn hOut ""
        forM_ (S.toList $ imports finalState) (hPutStrLn hOut)
        hPutStrLn hOut ""
        forM_ (reverse $ contents finalState) (hPutStrLn hOut)
      putStrLn $ "bundle complete: " ++ output
    _ -> putStrLn "Usage: cjp-bundle <Input.hs> <Output.bundled>"

collect :: BundleState -> FilePath -> IO BundleState
collect s@BundleState{..} !path = do
  !content <- readFile path
  let !ls = lines content
  foldM processLine s ls

processLine :: BundleState -> String -> IO BundleState
processLine st@(BundleState mod pra imp con) !line
  | "{-# " `isPrefixOf` line =
      case pragmaType line of
        0 -> return st
        1 -> do
          let !norm = unwords $ words line
          return st {pragmas = S.insert norm pra}
        _ -> return st {contents = line : con}
  | "import " `isPrefixOf` line = do
      case findMyModulePath line of
        Just !modPath -> do
          let !modName = takeBaseName modPath
          if S.member modName mod then return st
          else collect st {seenModules = S.insert modName mod} modPath
        Nothing -> do
          let !norm = unwords $ words line
          return st {imports = S.insert norm imp}
  | "module " `isPrefixOf` line = return st
  | otherwise = return st {contents = line : con}

pragmaType :: String -> Int
pragmaType !l
  | "HLINT" `isInfixOf` l = 0 -- 捨てる
  | any (`isInfixOf` l) ["LANGUAGE", "OPTIONS_GHC", "UNSAFE", "TRUSTWORTHY"] = 1 -- global
  | otherwise = 2 -- それ以外

findMyModulePath :: String -> Maybe FilePath
findMyModulePath !line = do
  let !ws = words line
  guard $ length ws >= 2
  let !imp : _ = ws
  guard $ imp == "import"
  
  let !rawModName = ws !! 1
  let !cleanName = takeWhile (`notElem` "();") rawModName
  
  guard $ S.member cleanName myModules
  
  return $ libRoot </> map (\c -> if c == '.' then pathSeparator else c) cleanName <.> "hs"